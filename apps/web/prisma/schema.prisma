generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // directUrl is optional - only needed for migrations when using connection pooling
  // directUrl = env("DIRECT_URL")
}

model User {
  id                          String             @id @default(cuid())
  email                       String             @unique
  name                        String?
  passwordHash                String
  firmName                    String?
  phone                       String?
  address                     String?
  createdAt                   DateTime           @default(now())
  updatedAt                   DateTime           @updatedAt
  timeEntries                 TimeEntry[]
  trustTransactionsEntered    TrustTransaction[] @relation("TrustTransactionEnteredBy")
  trustTransactionsVoided     TrustTransaction[] @relation("TrustTransactionVoidedBy")
  trustAuditLogs              TrustAuditLog[]
  tasksAssigned               Task[]             @relation("TaskAssignee")
  tasksCreated                Task[]             @relation("TaskCreator")
}

model Client {
  id           String        @id @default(cuid())
  name         String
  email        String?
  phone        String?
  address      String?
  notes        String?
  status       ClientStatus  @default(ACTIVE)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  matters      Matter[]
  trustLedgers TrustLedger[]
}

model Matter {
  id           String          @id @default(cuid())
  clientId     String
  client       Client          @relation(fields: [clientId], references: [id], onDelete: Cascade)
  name         String
  description  String?
  matterNumber String          @unique
  status       MatterStatus    @default(OPEN)
  practiceArea String?
  openDate     DateTime        @default(now())
  closeDate    DateTime?
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  timeEntries  TimeEntry[]
  documents    Document[]
  events       CalendarEvent[]
  invoices     Invoice[]
  trustLedgers TrustLedger[]
  tasks        Task[]

  @@index([clientId])
}

model TimeEntry {
  id                String           @id @default(cuid())
  matterId          String
  matter            Matter           @relation(fields: [matterId], references: [id], onDelete: Cascade)
  userId            String
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  description       String
  duration          Int              // Duration in minutes
  date              DateTime
  billable          Boolean          @default(true)
  rate              Decimal?         @db.Decimal(10, 2)
  invoiceLineItemId String?
  invoiceLineItem   InvoiceLineItem? @relation(fields: [invoiceLineItemId], references: [id], onDelete: SetNull)
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  @@index([matterId])
  @@index([userId])
  @@index([invoiceLineItemId])
}

model Document {
  id        String   @id @default(cuid())
  matterId  String
  matter    Matter   @relation(fields: [matterId], references: [id], onDelete: Cascade)
  name      String
  filename  String
  mimeType  String
  size      Int
  path      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([matterId])
}

model CalendarEvent {
  id          String    @id @default(cuid())
  matterId    String?
  matter      Matter?   @relation(fields: [matterId], references: [id], onDelete: SetNull)
  title       String
  description String?
  startTime   DateTime
  endTime     DateTime
  allDay      Boolean   @default(false)
  location    String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([matterId])
}

enum ClientStatus {
  ACTIVE
  INACTIVE
  ARCHIVED
}

enum MatterStatus {
  OPEN
  CLOSED
  PENDING
}

enum InvoiceStatus {
  DRAFT
  SENT
  PAID
  OVERDUE
  CANCELLED
}

model Invoice {
  id            String            @id @default(cuid())
  invoiceNumber String            @unique
  matterId      String
  matter        Matter            @relation(fields: [matterId], references: [id], onDelete: Cascade)
  status        InvoiceStatus     @default(DRAFT)
  issueDate     DateTime          @default(now())
  dueDate       DateTime
  subtotal      Decimal           @db.Decimal(10, 2)
  taxRate       Decimal           @default(0) @db.Decimal(5, 2)
  taxAmount     Decimal           @db.Decimal(10, 2)
  total         Decimal           @db.Decimal(10, 2)
  amountPaid    Decimal           @default(0) @db.Decimal(10, 2)
  notes         String?
  sentAt        DateTime?
  paidAt        DateTime?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  lineItems     InvoiceLineItem[]
  payments      Payment[]

  @@index([matterId])
  @@index([status])
}

model InvoiceLineItem {
  id          String      @id @default(cuid())
  invoiceId   String
  invoice     Invoice     @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  description String
  quantity    Decimal     @db.Decimal(10, 2) // hours
  rate        Decimal     @db.Decimal(10, 2)
  amount      Decimal     @db.Decimal(10, 2)
  date        DateTime?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  timeEntries TimeEntry[]

  @@index([invoiceId])
}

model Payment {
  id            String        @id @default(cuid())
  invoiceId     String
  invoice       Invoice       @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  amount        Decimal       @db.Decimal(10, 2)
  paymentDate   DateTime      @default(now())
  paymentMethod PaymentMethod
  reference     String?
  notes         String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  @@index([invoiceId])
}

enum PaymentMethod {
  CASH
  CHECK
  CREDIT_CARD
  BANK_TRANSFER
  OTHER
}

// Trust/IOLTA Accounting
model TrustAccount {
  id                    String             @id @default(cuid())
  name                  String
  accountNumber         String             @unique
  bankName              String
  routingNumber         String?
  description           String?
  isActive              Boolean            @default(true)
  bankBalance           Decimal            @default(0) @db.Decimal(12, 2)
  lastReconciledAt      DateTime?
  lastReconciledBalance Decimal?           @db.Decimal(12, 2)
  nextTransactionNumber Int                @default(1) // Counter for sequential transaction numbers
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt
  ledgers               TrustLedger[]
  transactions          TrustTransaction[]
  auditLogs             TrustAuditLog[]
}

model TrustLedger {
  id              String             @id @default(cuid())
  trustAccountId  String
  trustAccount    TrustAccount       @relation(fields: [trustAccountId], references: [id], onDelete: Cascade)
  clientId        String
  client          Client             @relation(fields: [clientId], references: [id], onDelete: Cascade)
  matterId        String?
  matter          Matter?            @relation(fields: [matterId], references: [id], onDelete: SetNull)
  balance         Decimal            @default(0) @db.Decimal(12, 2)
  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt
  transactions    TrustTransaction[]

  @@unique([trustAccountId, clientId, matterId])
  @@index([trustAccountId])
  @@index([clientId])
  @@index([matterId])
}

model TrustTransaction {
  id                 String              @id @default(cuid())
  transactionNumber  Int                 // Sequential number per trust account for audit trail
  trustAccountId     String
  trustAccount       TrustAccount        @relation(fields: [trustAccountId], references: [id], onDelete: Cascade)
  trustLedgerId      String
  trustLedger        TrustLedger         @relation(fields: [trustLedgerId], references: [id], onDelete: Cascade)
  type               TrustTransactionType
  amount             Decimal             @db.Decimal(12, 2)
  runningBalance     Decimal             @db.Decimal(12, 2)
  description        String
  reference          String?             // External reference number
  payee              String?             // For withdrawals - who received the funds
  payor              String?             // For deposits - who sent the funds
  checkNumber        String?
  source             TrustFundSource?    // How funds were received/disbursed
  transactionDate    DateTime            @default(now())
  clearedDate        DateTime?
  isCleared          Boolean             @default(false)

  // Audit trail - who entered this transaction
  enteredById        String?
  enteredBy          User?               @relation("TrustTransactionEnteredBy", fields: [enteredById], references: [id], onDelete: SetNull)

  // Voiding (transactions are never deleted, only voided)
  isVoided           Boolean             @default(false)
  voidedAt           DateTime?
  voidedById         String?
  voidedBy           User?               @relation("TrustTransactionVoidedBy", fields: [voidedById], references: [id], onDelete: SetNull)
  voidReason         String?
  voidingTransactionId String?  @unique  // Reference to the reversing transaction
  voidingTransaction TrustTransaction?   @relation("VoidingTransaction", fields: [voidingTransactionId], references: [id])
  voidedTransaction  TrustTransaction?   @relation("VoidingTransaction")

  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt

  @@unique([trustAccountId, transactionNumber])
  @@index([trustAccountId])
  @@index([trustLedgerId])
  @@index([transactionDate])
  @@index([type])
  @@index([enteredById])
  @@index([isVoided])
}

enum TrustTransactionType {
  DEPOSIT
  WITHDRAWAL
  TRANSFER_IN
  TRANSFER_OUT
  INTEREST
  BANK_FEE
  VOID_REVERSAL      // Reversing entry for voided transaction
}

enum TrustFundSource {
  WIRE_TRANSFER
  CHECK
  CASH
  ACH
  CREDIT_CARD        // Note: Some jurisdictions prohibit CC for trust
  MONEY_ORDER
  CASHIERS_CHECK
  INTERNAL_TRANSFER
  OTHER
}

// Audit log for trust account changes - immutable record
model TrustAuditLog {
  id                String   @id @default(cuid())
  trustAccountId    String
  trustAccount      TrustAccount @relation(fields: [trustAccountId], references: [id], onDelete: Cascade)
  trustLedgerId     String?
  action            String   // TRANSACTION_CREATED, TRANSACTION_VOIDED, BALANCE_RECONCILED, etc.
  entityType        String   // TrustTransaction, TrustLedger, TrustAccount
  entityId          String
  previousValue     String?  @db.Text // JSON of previous state
  newValue          String?  @db.Text // JSON of new state
  userId            String?
  user              User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  ipAddress         String?
  userAgent         String?
  timestamp         DateTime @default(now())

  @@index([trustAccountId])
  @@index([trustLedgerId])
  @@index([entityType, entityId])
  @@index([timestamp])
  @@index([userId])
}

// Tasks
model Task {
  id          String       @id @default(cuid())
  title       String
  description String?      @db.Text
  status      TaskStatus   @default(NOT_STARTED)
  priority    TaskPriority @default(MEDIUM)
  dueDate     DateTime?
  completedAt DateTime?

  // Optional link to matter
  matterId    String?
  matter      Matter?      @relation(fields: [matterId], references: [id], onDelete: SetNull)

  // Assignee
  assigneeId  String?
  assignee    User?        @relation("TaskAssignee", fields: [assigneeId], references: [id], onDelete: SetNull)

  // Creator (for audit)
  createdById String?
  createdBy   User?        @relation("TaskCreator", fields: [createdById], references: [id], onDelete: SetNull)

  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  @@index([matterId])
  @@index([assigneeId])
  @@index([status])
  @@index([dueDate])
  @@index([priority])
}

enum TaskStatus {
  NOT_STARTED
  IN_PROGRESS
  COMPLETED
}

enum TaskPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

// Application-wide settings (singleton row)
model Settings {
  id                String   @id @default("default")
  firmName          String?
  address           String?
  city              String?
  state             String?
  zip               String?
  phone             String?
  email             String?
  website           String?
  defaultHourlyRate Decimal  @default(450) @db.Decimal(10, 2)
  helcimApiToken    String?
  helcimAccountId   String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

// Appointment Scheduler Settings (singleton row)
model SchedulerSettings {
  id                    String   @id @default("default")
  isEnabled             Boolean  @default(false)
  // Availability - JSON array of { dayOfWeek: 0-6, startTime: "09:00", endTime: "17:00" }
  availability          String?  @db.Text
  consultationDuration  Int      @default(30)  // minutes
  consultationFee       Decimal  @default(150) @db.Decimal(10, 2)
  bufferTime            Int      @default(15)  // minutes between appointments
  minAdvanceBooking     Int      @default(24)  // hours - minimum notice required
  maxAdvanceBooking     Int      @default(30)  // days - how far ahead can book
  preventSameDayBooking Boolean  @default(true)
  requirePaymentUpfront Boolean  @default(true)
  // Practice areas offered for consultations
  practiceAreas         String?  @db.Text  // JSON array of strings
  confirmationMessage   String?  @db.Text
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
}

// Client Appointments
model Appointment {
  id                  String            @id @default(cuid())
  // Scheduling
  startTime           DateTime
  endTime             DateTime
  duration            Int               // minutes
  // Client info
  clientName          String
  clientEmail         String
  clientPhone         String?
  practiceArea        String?
  notes               String?           @db.Text
  // Status
  status              AppointmentStatus @default(PENDING)
  // Payment
  consultationFee     Decimal           @db.Decimal(10, 2)
  paymentStatus       PaymentStatus     @default(UNPAID)
  helcimTransactionId String?
  paidAt              DateTime?
  // Calendar integration
  calendarEventId     String?           // Link to CalendarEvent if created
  // Timestamps
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt
  cancelledAt         DateTime?
  cancellationReason  String?
  // Reminders
  reminderSentAt      DateTime?

  @@index([startTime])
  @@index([status])
  @@index([clientEmail])
}

enum AppointmentStatus {
  PENDING     // Awaiting payment/confirmation
  CONFIRMED   // Paid and confirmed
  CANCELLED   // Cancelled by client or firm
  COMPLETED   // Appointment has occurred
  NO_SHOW     // Client didn't show up
}

enum PaymentStatus {
  UNPAID
  PAID
  REFUNDED
}
